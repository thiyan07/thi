<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Experiments - Code Collection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .experiment {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .experiment:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .experiment-title {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-label {
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .section-content {
            color: #333;
            margin-left: 10px;
        }

        .code-container {
            position: relative;
            background: #1e1e1e;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .code-label {
            color: #fff;
            font-weight: bold;
            font-size: 0.9em;
        }

        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s;
        }

        .copy-btn:hover {
            background: #764ba2;
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .copy-btn.copied {
            background: #28a745;
        }

        pre {
            margin: 0;
            overflow-x: auto;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #d4d4d4;
            line-height: 1.5;
        }

        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .comment { color: #6a9955; }

        .footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¤– AI Experiments - Code Collection</h1>

        <!-- Experiment 1 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 1: 8â€‘Puzzle (A*)</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Solves the 8â€‘puzzle using A* search with cost = number of misplaced tiles; uses a priority queue and reconstructs the path when cost hits 0.[1]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">The heuristic "misplaced tiles" is admissible, so A* finds an optimal solution for solvable instances; neighbors are generated by sliding the blank up/down/left/right.[1]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code1')">Copy</button>
                </div>
                <pre><code id="code1">import heapq

N = 3
DIRS = [(-1,0),(1,0),(0,-1),(0,1)]

def h(s, goal):
    return sum(s[i]!=goal[i] and s[i]!=0 for i in range(9))

def neighbors(s):
    z = s.index(0); x,y = divmod(z,3)
    for dx,dy in DIRS:
        nx,ny = x+dx, y+dy
        if 0<=nx<3 and 0<=ny<3:
            nz = 3*nx+ny
            t = list(s); t[z],t[nz] = t[nz],t[z]
            yield tuple(t)

def astar(start, goal):
    pq = [(h(start,goal), 0, start, None)]
    came = {}
    g = {start:0}
    seen = set()
    while pq:
        f, gc, s, par = heapq.heappop(pq)
        if s in seen: continue
        came[s] = par; seen.add(s)
        if s==goal:
            path=[]
            while s is not None: path.append(s); s=came[s]
            return list(reversed(path))
        for nb in neighbors(s):
            ng = gc+1
            if ng < g.get(nb, 1e9):
                g[nb]=ng
                heapq.heappush(pq,(ng+h(nb,goal), ng, nb, s))
    return None

start = (1,2,3,5,6,0,7,8,4)
goal  = (1,2,3,5,8,6,0,7,4)
sol = astar(start, goal)
for state in sol: print(*[state[i:i+3] for i in range(0,9,3)], sep="\n"); print()</code></pre>
            </div>
        </div>

        <!-- Experiment 2 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 2: Nâ€‘Queens (Backtracking)</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Places N queens on an NÃ—N board so none attack each other using recursive backtracking and safety checks for row/diagonals.[2]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">At each column, try a safe row; backtrack when no safe row exists; terminates after placing all N queens.[2]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code2')">Copy</button>
                </div>
                <pre><code id="code2">def solve_n_queens(N):
    cols, d1, d2, pos = set(), set(), set(), []
    def bt(c=0):
        if c==N: return True
        for r in range(N):
            if r in cols or (r-c) in d1 or (r+c) in d2: continue
            cols.add(r); d1.add(r-c); d2.add(r+c); pos.append(r)
            if bt(c+1): return True
            cols.remove(r); d1.remove(r-c); d2.remove(r+c); pos.pop()
        return False
    bt()
    board = [[0]*N for _ in range(N)]
    for c,r in enumerate(pos): board[r][c]=1
    return board

N = 8
ans = solve_n_queens(N)
for row in ans: print(" ".join(map(str,row)))</code></pre>
            </div>
        </div>

        <!-- Experiment 3 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 3: A* on Graph</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Implements A* on a symbolic graph with a heuristic table; returns the found path Aâ†’â€¦â†’G.[3]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Uses f(n)=g(n)+h(n) to always expand the most promising node; reconstructs path from parent map.[3]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code3')">Copy</button>
                </div>
                <pre><code id="code3">import heapq

G = {
  'A': [('B',2),('E',3)],
  'B': [('C',1),('G',15)],
  'C': [],
  'D': [('G',1)],
  'E': [('D',6)]
}
H = {'A':11,'B':5,'C':23,'D':1,'E':7,'G':0}

def astar(s, t):
    pq=[(H[s],0,s,None)]
    came, best = {}, {s:0}
    seen=set()
    while pq:
        f,gc,u,par = heapq.heappop(pq)
        if u in seen: continue
        came[u]=par; seen.add(u)
        if u==t:
            path=[]
            while u is not None: path.append(u); u=came[u]
            return list(reversed(path))
        for v,w in G.get(u,[]):
            ng = gc+w
            if ng < best.get(v,1e9):
                best[v]=ng
                heapq.heappush(pq,(ng+H.get(v,1e9), ng, v, u))
    return None

print(astar('A','G'))</code></pre>
            </div>
        </div>

        <!-- Experiment 4 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 4: Hill Climbing</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Starts from a random x, evaluates neighbors at step size, moves to better neighbor until no improvement.[3]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Greedy ascent converges to local maximum near x=2 for this concave quadratic.[3]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code4')">Copy</button>
                </div>
                <pre><code id="code4">import random

f = lambda x: -(x*x) + 4*x + 10

def hill(start=None, step=0.1, it=1000):
    x = random.uniform(-10,10) if start is None else start
    fx = f(x)
    for _ in range(it):
        candidates = [x-step, x+step]
        vals = [f(c) for c in candidates]
        j = 0 if vals[0]>=vals[1] else 1
        if vals[j] > fx:
            x, fx = candidates[j], vals[j]
        else:
            break
    return x, fx

print(hill())</code></pre>
            </div>
        </div>

        <!-- Experiment 5 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 5: Alphaâ€“Beta Pruning</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Runs depthâ€‘limited minimax with alphaâ€“beta pruning over a full binary tree (values array), prints optimal value.[4]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Alpha (best for MAX so far) and beta (best for MIN so far) bounds cut off branches that can't influence the result.[4]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code5')">Copy</button>
                </div>
                <pre><code id="code5">MINV, MAXV = -10**9, 10**9

def minimax(depth, idx, max_turn, values, alpha, beta, max_depth=3):
    if depth==max_depth: return values[idx]
    if max_turn:
        best = MINV
        for i in range(2):
            best = max(best, minimax(depth+1, idx*2+i, False, values, alpha, beta, max_depth))
            alpha = max(alpha, best)
            if beta <= alpha: break
        return best
    else:
        best = MAXV
        for i in range(2):
            best = min(best, minimax(depth+1, idx*2+i, True, values, alpha, beta, max_depth))
            beta = min(beta, best)
            if beta <= alpha: break
        return best

values = [3,5,6,9,1,2,0,-1]
print("Optimal:", minimax(0,0,True,values,MINV,MAXV))</code></pre>
            </div>
        </div>

        <!-- Experiment 6 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 6: Sudoku (Backtracking)</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Classic backtracking CSP: pick first empty, try 1..9 consistent with row/column/box, recurse, backtrack on failure.[4]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Sudoku constraints are local; backtracking with legality checks systematically finds a valid assignment if one exists.[4]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code6')">Copy</button>
                </div>
                <pre><code id="code6">def find_empty(b):
    for r in range(9):
        for c in range(9):
            if b[r][c]==0: return r,c
    return None

def legal(b,r,c,v):
    if v in b[r]: return False
    if v in [b[i][c] for i in range(9)]: return False
    br, bc = (r//3)*3, (c//3)*3
    for i in range(br, br+3):
        for j in range(bc, bc+3):
            if b[i][j]==v: return False
    return True

def solve(b):
    spot = find_empty(b)
    if not spot: return True
    r,c = spot
    for v in range(1,10):
        if legal(b,r,c,v):
            b[r][c]=v
            if solve(b): return True
            b[r][c]=0
    return False

board = [
[5,3,0,0,7,0,0,0,0],
[6,0,0,1,9,5,0,0,0],
[0,9,8,0,0,0,0,6,0],
[8,0,0,0,6,0,0,0,3],
[4,0,0,8,5,3,0,0,1],
[7,0,0,0,2,0,0,0,6],
[0,6,0,0,0,0,2,8,0],
[0,0,0,4,1,9,0,0,5],
[0,0,0,0,8,0,0,7,9]]
solve(board)
for r in board: print(" ".join(map(str,r)))</code></pre>
            </div>
        </div>

        <!-- Experiment 7 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 7: Propositional Logic KB</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Defines proposition structures (Not/And/Or), a simple knowledge base with rules premiseâ†’conclusion, and forward-chaining inference until fixpoint.[5]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Evaluates composite formulas against the current set; if a rule's premise is true, add its conclusion; repeat until no new facts.[5]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code7')">Copy</button>
                </div>
                <pre><code id="code7">class Prop: 
    def __init__(self, name): self.name=name
    def __repr__(self): return self.name
class Not:
    def __init__(self,p): self.p=p
class And:
    def __init__(self,*ps): self.ps=ps
class Or:
    def __init__(self,*ps): self.ps=ps

class KB:
    def __init__(self): self.facts=set(); self.rules=[]
    def add(self,p): self.facts.add(p)
    def rule(self, prem, concl): self.rules.append((prem,concl))
    def eval(self, p):
        if isinstance(p, Prop): return p in self.facts
        if isinstance(p, Not):  return not self.eval(p.p)
        if isinstance(p, And):  return all(self.eval(x) for x in p.ps)
        if isinstance(p, Or):   return any(self.eval(x) for x in p.ps)
        return False
    def infer(self):
        changed=True
        while changed:
            changed=False
            for prem,concl in self.rules:
                if self.eval(prem) and concl not in self.facts:
                    self.facts.add(concl); changed=True

A,B,C,D,E,F = map(Prop,"A B C D E F".split())
kb = KB()
kb.add(A); kb.add(B)
kb.rule(A, C)
kb.rule(B, D)
kb.rule(And(C,D), E)
kb.rule(Or(A, Not(B)), E)
kb.rule(And(C, Not(D)), F)
kb.infer()
print("Facts:", sorted(p.name for p in kb.facts))</code></pre>
            </div>
        </div>

        <!-- Experiment 8 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 8: Wumpus World (Toy)</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Simulates a 4Ã—4 world with agent, gold, Wumpus; moves agent through scripted actions, picks gold, checks win/lose states.[5]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Maintains state; "safe" squares exclude Wumpus; terminates after success or death; illustrates propositional reasoning's effect via safety checks.[5]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code8')">Copy</button>
                </div>
                <pre><code id="code8">class WumpusWorld:
    def __init__(self):
        self.N=4; self.agent=(0,0); self.gold=(2,2); self.wumpus=(1,0)
        self.gold_taken=False; self.over=False
    def safe(self, pos): return pos!=self.wumpus
    def move(self, d):
        if self.over: return
        x,y=self.agent
        mv={'up':(-1,0),'down':(1,0),'left':(0,-1),'right':(0,1)}.get(d)
        if not mv: return
        nx,ny=x+mv[0], y+mv[1]
        if 0<=nx<self.N and 0<=ny<self.N:
            if not self.safe((nx,ny)): self.over=True; print("Wumpus!"); return
            self.agent=(nx,ny); 
            if self.agent==self.gold and not self.gold_taken: self.gold_taken=True; print("Grabbed gold")
    def status(self):
        if self.over: return "Dead"
        if self.gold_taken and self.agent==(0,0): return "Success"
        return "Exploring"

w=WumpusWorld()
for a in ['right','down','down','right','up','up','left','left']:
    w.move(a); print(w.status())</code></pre>
            </div>
        </div>

        <!-- Experiment 9 -->
        <div class="experiment">
            <div class="experiment-title">Experiment 9: Gaussian Naive Bayes</div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code9')">Copy</button>
                </div>
                <pre><code id="code9">X = [[1.0,2.0],[2.0,1.0],[3.0,5.0],[4.0,4.0],[5.0,5.0]]
y = [0,0,1,1,1]
X_train, X_test = X[:4], X[4:]
y_train, y_test = y[:4], y[4:]

def fit_gaussian_constants(X, y):
    stats = {}
    for xi, c in zip(X, y):
        s = stats.setdefault(c, {"sum":[0.0,0.0], "count":0})
        s["sum"][0] += xi[0]; s["sum"][1] += xi[1]; s["count"] += 1
    for c, s in stats.items():
        n = s["count"]
        s["mean"] = [s["sum"][0]/n, s["sum"][1]/n]
        s["var"]  = [0.1, 0.1]
    return stats

def predict_constants(Xt, stats):
    preds = []
    for x in Xt:
        class_score = {}
        for c, s in stats.items():
            score = 1.0
            for v in s["var"]:
                score *= 1 / (2.506628 * (v ** 0.5))
            class_score[c] = score
        preds.append(max(class_score, key=class_score.get))
    return preds

model = fit_gaussian_constants(X_train, y_train)
pred = predict_constants(X_test, model)
acc = sum(p == a for p, a in zip(pred, y_test)) / len(y_test)

print("Predictions:", pred)
print("Actual:", y_test)
print("Accuracy:", acc)</code></pre>
            </div>
        </div>

        <!-- Experiment 10a -->
        <div class="experiment">
            <div class="experiment-title">Experiment 10a: Chatbot (Menu-driven)</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Simple CLI chatbot with greetings, age guessing via remainders, jokes, facts, trivia, calculator, simulated weather/news, and exit.[6]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">A looped menu dispatches to functions; input handling and basic randomness deliver varied responses.[6]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code10a')">Copy</button>
                </div>
                <pre><code id="code10a">import random, datetime, sys

def age_guess():
    try:
        r3=int(input("r%3: ")); r5=int(input("r%5: ")); r7=int(input("r%7: "))
    except: return None
    return (r3*70 + r5*21 + r7*15) % 105

def calc():
    try:
        a=float(input("a: ")); op=input("op(+,-,*,/): ").strip(); b=float(input("b: "))
        if op=='+': print(a+b)
        elif op=='-': print(a-b)
        elif op=='*': print(a*b)
        elif op=='/': print("Err div0" if b==0 else a/b)
        else: print("Bad op")
    except: print("Bad input")

jokes = ["Why do programmers prefer dark mode? Because light attracts bugs!",
         "Why do Java devs wear glasses? Because they don't C."]
facts = ["Python named after Monty Python.", "First 1GB HDD weighed ~500 lbs (1980)."]
news  = ["AI transforming industries.", "Python most popular language."]
triv  = {"Who developed Python?":"Guido van Rossum",
         "What does HTML stand for?":"HyperText Markup Language"}

def main():
    name = input("Your name: ").strip() or "Friend"
    print(f"Hi {name}! Menu: 1-Weather 2-News 3-Calc 4-Joke 5-Fact 6-Trivia 7-Guess age 8-Exit")
    while True:
        c=input("> ").strip()
        if c=='1': print(f"Weather: {random.choice(['sunny','rainy','cloudy'])}, {random.randint(-5,38)}C")
        elif c=='2': print(random.choice(news))
        elif c=='3': calc()
        elif c=='4': print(random.choice(jokes))
        elif c=='5': print(random.choice(facts))
        elif c=='6':
            q,ans = random.choice(list(triv.items()))
            print(q); print("Correct!" if input("Ans: ").strip().lower()==ans.lower() else f"Ans: {ans}")
        elif c=='7':
            age = age_guess()
            if age is not None: print(f"Age: {age}")
        elif c=='8':
            print("Bye!", datetime.datetime.now().strftime("%H:%M")); break
        else: print("1..8 only")
if __name__=="__main__": main()</code></pre>
            </div>
        </div>

        <!-- Experiment 10b -->
        <div class="experiment">
            <div class="experiment-title">Experiment 10b: Rockâ€“Paperâ€“Scissors</div>
            <div class="section">
                <div class="section-label">Aim:</div>
                <div class="section-content">Loops reading user choice, randomly draws computer choice, compares per standard rules, supports "exit" to quit.[6]</div>
            </div>
            <div class="section">
                <div class="section-label">Algorithm:</div>
                <div class="section-content">Enumerates the three winning relations; tie when equal; otherwise loss.[6]</div>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-label">Code:</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code10b')">Copy</button>
                </div>
                <pre><code id="code10b">import random

WINS = {('Rock','Scissors'), ('Paper','Rock'), ('Scissors','Paper')}
CHO = ['Rock','Paper','Scissors']

print("Rock, Paper, Scissors (type exit)")
while True:
    me = input("Your choice: ").strip().capitalize()
    if me=='Exit': print("Thanks!"); break
    if me not in CHO: print("Pick Rock/Paper/Scissors"); continue
    ai = random.choice(CHO)
    print("Computer:", ai)
    if me==ai: print("Tie!")
    elif (me,ai) in WINS: print("You win!")
    else: print("You lose!")</code></pre>
            </div>
        </div>

        <div class="footer">
            <p>All code examples are ready to copy and use!</p>
        </div>
    </div>

    <script>
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy code. Please select and copy manually.');
            });
        }
    </script>
</body>
</html>
